---
title: 如何实现虚拟滚动
tags:
  - 功能
---
## 为什么需要虚拟滚动

假设一个 vue 组件用 v-for 一次性不分页渲染 100000 条列表数据，且不说从后端请求这些数据所需要的时间，光是从加载数据到可以交互的时间就能直观感觉到缓慢，数据量越大感觉越明显，这种性能完全无法达到良好的用户体验，但这种一次性渲染大量列表数据的需求其实挺常见，因此需要一种手段优化大数据列表的性能，虚拟滚动就是最主流的解决方案，不过在解释虚拟滚动的原理之前，需要先了解普通渲染出现性能瓶颈的原因
## 分析

首先创建一个 vue 组件用于渲染列表数据

```html title="src/components/NormalScroller.vue"
<script setup lang="ts">
const props = defineProps<{
  // 可视区高度
  height: number
  // 所有数据
  data: { id: number; height: number }[]
}>()
</script>

<template>
  <div id="scroller" :style="{ height: props.height + 'px' }">
    <div class="item" v-for="item in data" :key="item.id" :style="{ height: item.height + 'px' }">
      {{ item.id }}
    </div>
  </div>
</template>

<style scoped>
#scroller {
  border: 1px solid #eee;
  overflow: auto;
}

.item {
  box-sizing: border-box;
  border: 1px solid #eee;
  background-color: #000;
  color: #fff;
}
</style>
```

在父组件中创建数据并向该组件传递数据，每个列表项高度固定

```html title="src/App.vue"
<script setup lang="ts">
import NormalScroller from './components/NormalScroller.vue'
import { ref, type Ref, onMounted } from 'vue'

const data: Ref<{ id: number; height: number }[]> = ref([])

function getData() {
  const temp = []
  for (let i = 0; i < 100000; i++) {
    temp.push({
      id: i + 1,
      height: 50
    })
  }
  data.value = temp
}

onMounted(() => {
  getData()
})
</script>

<template>
  <NormalScroller :height="500" :data="data"></NormalScroller>
</template>
```

### 加载速度

首先分析一下页面的加载速度

把项目跑起来后，打开页面，打开开发者工具，进入开发者工具的 `Performance` 面板，点击左上角的 `Record and reload` 按钮，点击后浏览器就会自动刷新并且开始录制从刷新到加载完成的性能数据（不需要手动点击 `Stop`）

录制完后得到的信息很多，重点关注一下底部 `Summary` 的指标，

其中 `Scripting` 表示加载过程中脚本执行的时间，因为脚本执行过程中会阻塞页面的渲染，同时如果脚本修改 DOM 会导致重排与重绘，是影响页面加载速度的重要因素

`Rendering` 表示实际页面的渲染耗时，包括重排、重绘、合成的过程

`Painting` 表示页面重绘的耗时

`Idle` 表示主线程的空闲时间，不影响页面加载速度

可以看到，单单 `Scripting` + `Rendering` + `Painting` 加起来的时间已经超过 `4s` ，这显然是不能被接受

### 滚动帧率

打开开发者工具，按下 `Ctrl + Shift + p` 后出现命令选择下拉框，搜索 `Show frames per second(FPS) meter` ，这个命令会在页面左上角出现一个可以实时查看帧率的小弹窗，通过滚动列表分析页面的交互流畅度

目前流畅度还是可以的，稳定在 60 帧左右，因为所有 DOM 都已经加载完，滚动过程不会发生重排重绘

### Lighthouse

打开开发者工具，进入 `Lighthouse` 面板，分别勾选 `Navigation`、`Desktop`、`Performance` 后点击 `Analyze page load` 按钮，这个工具就会自动从各个方面分析页面的性能并给出相应分数和修改建议

可以看到 `First Contentful Paint` 即 `FCP` ，这个指标表示浏览器首次绘制来自 DOM 内容的耗时 ，用于评估用户首次看到有用内容的耗时，简单来说就是耗时越短，加载速度越快，这里分析出将近 `1s` 而且用黄色高亮，是需要优化的点

往下看有这个工具提供的优化建议，重点看一下 `Avoid an excessive DOM size` ，表示你的页面 DOM 节点数量过多，显示包括所有节点数量，最深的节点嵌套层级，最大包含的子节点数量
 
大量的 DOM 节点不仅影响加载速度，还会因为交互时发生重排重绘的范围过大导致页面卡顿，同时还存在因为引用大量节点导致内存溢出的隐患

按照官方介绍

> 当 body 元素所含的节点超过 800 个左右时发出警告
> 当 body 元素所含的节点数量超过约 1,400 个时出现的错误

### 总结

根据上面的分析，可以得出一个结论：加载慢是因为 DOM 节点数量太多，且大部分为可视区以外的节点

因此可以得到一个优化的方向：只渲染可视区内节点，同时随滚动动态更新可视区内节点

## 源码

https://github.com/ReinerLau/virtual-scroller.git