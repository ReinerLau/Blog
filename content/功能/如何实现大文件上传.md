---
tags:
  - 项目
title: 如何实现大文件上传
---
## 为什么需要大文件上传

通常我们上传是通过 `<input />` 标签以提交表单的形式上传到服务器上，像下面这样：

```html
<input type="file" />
```

通常我们都是以上传小文件为主，比如图片、excel 表格文件之类，直接上传没有问题，发送给后端的速度很快

但难免有需要上传大文件的时候，比如视频，数据大的 excel 表格文件，如果还是直接上传，可能会有几个结果：

- **页面卡死**：上传过程中文件会占用浏览器内存
- **上传慢**：网络请求需要时间，文件越大等待时间越长
- **上传失败**：请求时间越长，容易因为各种因素中断上传操作，比如网络请求有时间限制，容易因为超时而请求失败，
- **重新上传**：上传失败后导致需要从头开始等待上传

## 切片

所谓切片就是将大文件切割成多个切片后上传，每个切片就是组成大文件的一部分数据，后端收到所有切片后再合并成完整的大文件，这样做有 3 个好处：

- **提升上传速度**：利用 HTTP 并发性，同时上传多个切片
- **实现断点续传**：如果上传流程中断，后续可以通过检查已上传的切片判断从哪里开始继续上传

首先要实现对大文件的切割，需要使用 Blob 对象的 `slice` 方法，这个方法类似数组的 `slice` 方法从数组中提取指定索引范围内的元素，不同的是这个方法作用于 Blob 对象，即从一个大的二进制数据中提取指定字节范围内的二进制数据

```ts
/**
 * 每个切片的大小
 */
const CHUNK_SIZE = 10 * 1024 * 1024
/**
 * 将文件拆分成多个切片
 * @param file 上传的文件对象
 * @param size 每个切片的大小
 */
const createFileChunk = (file: File, size = CHUNK_SIZE) => {
  const fileChunkList: Blob[] = []
  let cur = 0
  while (cur < file.size) {
    fileChunkList.push(file.slice(cur, cur + size))
    cur += size
  }
  return fileChunkList
}
```

> 文件和 Blob 对象有什么关系？首先每个上传的文件都是一个 File 对象，File 对象继承自 Blob 对象，具有 Blob 对象所有功能，Blob 对象用于存储二进制数据，文件本质也是二进制数据，只是相比普通的二进制数据多了文件名、最后修改时间等额外信息

现在我们就得到文件对应一组切片，需要同时上传到后端

那么后端应该在什么时候合并所有切片呢？自然是所有切片上传完成后，那么后端怎么知道什么时候所有上传完成呢？这里可以通过前端在所有切片上传完成后额外发送一个合并请求通知后端进行合并来实现

```ts
// 并发请求并等待所有请求完成
await Promise.all(requestList)
// 发起合并请求
await mergeRequest()
```

后端知道什么时候合并切片后，又该怎么知道如何合并切片呢？因为字节数据的合并顺序会影响最终合并文件是否和切割前一致，因此切片的合并顺序要和切割后的切片顺序保持一致，又因为每个切片完成上传的顺序不一定，因此在请求前要通过什么方式对切片标记顺序，这里可以在切片的名称加个顺序后缀

```ts
// 每个切片添加顺序后缀
data = fileChunkList.map((file, index) => ({
		chunk: file,
        chunkName: fileName + '-' + index
}))
```

后端在收到每个切片后会将切片数据临时存储起来，收到合并请求后按照切片名称排序后再合并，最后删除临时的切片数据

到这里，能实现个基本需求，不过还有优化的地方，假设文件切割出上百份切片并同时发起请求，你觉得会发生什么？浏览器会在建立 TCP 连接的时候就卡死了，因此我们要限制一下并发请求的数量

```ts
/**
 * 控制并发请求数量
 * @param forms 提交数据列表
 * @param max 最大请求数量
 */
const sendRequest = (forms: { formData: FormData; index: number; status: number }[], max = 4) => {
  return new Promise((resolve, reject) => {
    let cur = max
    let counter = 0
    const start = () => {
      while (counter < forms.length && cur > 0) {
        const idx = forms.findIndex(
          (item) => item.status === Status.WAIT
        )
        // 表示只剩下正在上传的切片停止循环
        if (idx === -1) break
        const formData = forms[idx].formData
        const index = forms[idx].index
        request({
          url: 'http://localhost:3000',
          data: formData,
          onProgress: createProgressHandler(data.value[index])
        })
          .then(() => {
            cur++
            counter++
            forms[idx].status = Status.DONE
            if (counter === forms.length) {
              resolve(true)
            } else {
              start()
            }
          })
        cur--
        forms[idx].status = Status.UPLOADING
      }
    }
    start()
  })
}
```

简单总结一下就是：

- 指定最大的并发数
- 不断轮询判断是否存在空闲的请求通道并且是否存在未上传的切片
- 未上传的切片不停地占用空闲的请求通道
- 直到所有切片上传完
## 秒传

## 断点

## 续传

## 优化

## 源码

https://github.com/ReinerLau/file-upload
